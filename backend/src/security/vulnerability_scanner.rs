/**
 * Vulnerability Scanner
 * 
 * Scans code for security vulnerabilities:
 * - CVE detection
 * - Dependency vulnerabilities
 * - Code vulnerabilities
 * - Configuration issues
 */
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use regex::Regex;

pub struct VulnerabilityScanner {
    cve_database: HashMap<String, CVEInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub severity: String,
    pub description: String,
    pub affected_files: Vec<String>,
    pub cve_id: Option<String>,
    pub fix_suggestion: Option<String>,
}

#[derive(Debug, Clone)]
struct CVEInfo {
    id: String,
    severity: String,
    description: String,
    affected_versions: Vec<String>,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            cve_database: HashMap::new(),
        }
    }

    /// Scan code for vulnerabilities
    pub fn scan_code(&self, code: &str, language: &str) -> Vec<Vulnerability> {
        let mut vulnerabilities = Vec::new();

        // Check for hardcoded secrets
        if self.detect_hardcoded_secrets(code) {
            vulnerabilities.push(Vulnerability {
                id: "HARDCODED_SECRET".to_string(),
                severity: "HIGH".to_string(),
                description: "Hardcoded secret detected (API keys, passwords, tokens)".to_string(),
                affected_files: vec![],
                cve_id: None,
                fix_suggestion: Some("Move secrets to environment variables or secure vault".to_string()),
            });
        }

        // Check for weak cryptography
        if self.detect_weak_crypto(code) {
            vulnerabilities.push(Vulnerability {
                id: "WEAK_CRYPTO".to_string(),
                severity: "MEDIUM".to_string(),
                description: "Weak cryptographic algorithm detected".to_string(),
                affected_files: vec![],
                cve_id: None,
                fix_suggestion: Some("Use strong cryptographic algorithms (AES-256, SHA-256+)".to_string()),
            });
        }

        // Check for insecure random
        if self.detect_insecure_random(code) {
            vulnerabilities.push(Vulnerability {
                id: "INSECURE_RANDOM".to_string(),
                severity: "MEDIUM".to_string(),
                description: "Insecure random number generation detected".to_string(),
                affected_files: vec![],
                cve_id: None,
                fix_suggestion: Some("Use cryptographically secure random number generators".to_string()),
            });
        }

        // Language-specific checks
        match language.to_lowercase().as_str() {
            "javascript" | "typescript" => {
                vulnerabilities.extend(self.scan_javascript(code));
            }
            "python" => {
                vulnerabilities.extend(self.scan_python(code));
            }
            "rust" => {
                vulnerabilities.extend(self.scan_rust(code));
            }
            _ => {}
        }

        vulnerabilities
    }

    fn detect_hardcoded_secrets(&self, code: &str) -> bool {
        let secret_patterns = vec![
            r"(?i)(api[_-]?key|apikey)\s*[:=]\s*['\"][^'\"]+['\"]",
            r"(?i)(password|passwd|pwd)\s*[:=]\s*['\"][^'\"]+['\"]",
            r"(?i)(secret|token|auth)\s*[:=]\s*['\"][^'\"]+['\"]",
            r"sk-[a-zA-Z0-9]{32,}",
            r"AKIA[0-9A-Z]{16}",
        ];

        for pattern in secret_patterns {
            if regex::Regex::new(pattern).unwrap_or_else(|_| regex::Regex::new("").unwrap()).is_match(code) {
                return true;
            }
        }
        false
    }

    fn detect_weak_crypto(&self, code: &str) -> bool {
        let weak_patterns = vec![
            r"(?i)(md5|sha1|des|rc4)\s*\(",
            r"(?i)crypto\.createHash\(['\"]md5['\"]",
            r"(?i)hashlib\.md5\(",
        ];

        for pattern in weak_patterns {
            if regex::Regex::new(pattern).unwrap().is_match(code) {
                return true;
            }
        }
        false
    }

    fn detect_insecure_random(&self, code: &str) -> bool {
        let insecure_patterns = vec![
            r"(?i)Math\.random\(",
            r"(?i)random\.random\(",
            r"(?i)rand\(\)",
        ];

        for pattern in insecure_patterns {
            if regex::Regex::new(pattern).unwrap_or_else(|_| regex::Regex::new("").unwrap()).is_match(code) {
                return true;
            }
        }
        false
    }

    fn scan_javascript(&self, code: &str) -> Vec<Vulnerability> {
        let mut vulns = Vec::new();

        // Check for innerHTML without sanitization
        if code.contains("innerHTML") && !code.contains("DOMPurify") && !code.contains("sanitize") {
            vulns.push(Vulnerability {
                id: "XSS_RISK".to_string(),
                severity: "HIGH".to_string(),
                description: "innerHTML usage without sanitization detected".to_string(),
                affected_files: vec![],
                cve_id: None,
                fix_suggestion: Some("Use textContent or sanitize HTML with DOMPurify".to_string()),
            });
        }

        vulns
    }

    fn scan_python(&self, code: &str) -> Vec<Vulnerability> {
        let mut vulns = Vec::new();

        // Check for pickle usage
        if code.contains("pickle") {
            vulns.push(Vulnerability {
                id: "PICKLE_RISK".to_string(),
                severity: "HIGH".to_string(),
                description: "Pickle usage detected - can execute arbitrary code".to_string(),
                affected_files: vec![],
                cve_id: None,
                fix_suggestion: Some("Use json or other safe serialization formats".to_string()),
            });
        }

        vulns
    }

    fn scan_rust(&self, code: &str) -> Vec<Vulnerability> {
        let mut vulns = Vec::new();

        // Check for unsafe blocks without proper documentation
        if code.matches("unsafe").count() > 0 {
            vulns.push(Vulnerability {
                id: "UNSAFE_CODE".to_string(),
                severity: "MEDIUM".to_string(),
                description: "Unsafe Rust code detected - ensure proper safety guarantees".to_string(),
                affected_files: vec![],
                cve_id: None,
                fix_suggestion: Some("Document safety invariants and ensure memory safety".to_string()),
            });
        }

        vulns
    }
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}
